{ binaryGlyphTokens }     = require './keyTokens'
comment                   = require './commentSignal'
{ createErlBoolean }      = require './type-utilities'
{ createErlIdentifier }   = require './type-utilities'
{ createErlIgnore }       = require './type-utilities'
{ createErlIndex }        = require './type-utilities'
{ createErlList }         = require './type-utilities'
{ createErlNil }          = require './type-utilities'
{ createErlNumber }       = require './type-utilities'
{ createErlString }       = require './type-utilities'
{ createErlSymbol }       = require './type-utilities'
{ deref }                 = require './keyTokens'
{ derefGlyph }            = require './keyTokens'
{ extractJsValue }        = require './type-utilities'
{ _false }                = require './keyTokens'
{ glyphTokens }           = require './keyTokens'
{ ignore }                = require './keyTokens'
{ ignore! }               = require './keyTokens'
{ ignore!Glyph }          = require './keyTokens'
{ ignoreIfTrue }          = require './keyTokens'
{ ignoreIfTrueGlyph }     = require './keyTokens'
{ ignoreUnlessTrue }      = require './keyTokens'
{ ignoreUnlessTrueGlyph } = require './keyTokens'
{ indexEnd }              = require './keyTokens'
{ indexStart }            = require './keyTokens'
{ keyTokens }             = require './keyTokens'
{ listEnd }               = require './keyTokens'
{ listStart }             = require './keyTokens'
{ nil }                   = require './keyTokens'
{ quasiquote }            = require './keyTokens'
{ quote }                 = require './keyTokens'
{ spliceUnquote }         = require './keyTokens'
{ unquote }               = require './keyTokens'
{ quasiquoteGlyph }       = require './keyTokens'
{ quoteGlyph }            = require './keyTokens'
{ spliceUnquoteGlyph }    = require './keyTokens'
{ unquoteGlyph }          = require './keyTokens'
{ reverse }               = require './linked-list'
{ _true }                 = require './keyTokens'

atomize = \token ->
  createErlValue = switch
    when nil? token       then createErlNil
    when ignore? token    then createErlIgnore
    when boolean? token   then ; createErlBoolean parseBoolean ;
    when string? token    then createErlString
    when identifer? token then createErlIdentifier
    when integer? token   then ; createErlNumber parseInt10 ;
    when float? token     then ; createErlNumber parseFloat10 ;
    else                       createErlSymbol
  createErlValue token

boolean? = \token ->
  token in [_false, _true]

float? = \token ->
  /^(-|\+)?[0-9](_|\d)*\.(\d|(\d(_|\d)*\d))$/.test token

binaryGlyph? = \token ->
  token in binaryGlyphTokens

glyph? = \token ->
  token in glyphTokens

ignore? = \token ->
  token == ignore

indexStart? = \token ->
  token == indexStart

integer? = \token ->
  /^(0(?!\.)|((-|\+)?[1-9](_|\d)*$))/.test token

listStart? = \token ->
  token == listStart

nil? = \token ->
  token == nil

_parse = (token, tokens) ->
  switch
    when listStart? token
      parseList tokens
    when indexStart? token
      parseIndex tokens
    when glyph? token
      parseGlyph (glyphIndex[token], tokens) 
    when binaryGlyph? token
      parseBinaryGlyph (binaryGlyphIndex[token], tokens)
    else
      atomize token

parse = \tokens ->
  return comment if tokens == comment
  _parse (tokens.shift(), tokens)

parseBinaryGlyph = (keyword, tokens) ->
  createErlList (
    createErlSymbol keyword
    createErlList (
      parse tokens
      createErlList (parse tokens)))

parseBoolean = \token ->
  token == _true

parseFloat10 = \token ->
  parseFloat ((stripUnderscores token), 10)

parseGlyph = (keyword, tokens) ->
  createErlList (
    (createErlSymbol keyword),
    (createErlList (parse tokens)))

parseIndex = \tokens ->
  jsIndex = {}
  key = null
  keyStep? = true

  until (token = tokens.shift()) == indexEnd
    if keyStep?
      key = _parse (token, tokens)
      keyStep? = false
    else
      jsIndex[extractJsValue key] = _parse (token, tokens)
      keyStep? = true

  createErlIndex jsIndex

parseInt10 = \token ->
  parseInt ((stripUnderscores token), 10)

parseList = \tokens ->
  erlList = createErlList ()
  until (token = tokens.shift()) == listEnd
    erlList = createErlList (
      (_parse (token, tokens)),
      erlList)
  reverse erlList

startsWith? = \char \token ->
  token[0] == char

stripUnderscores = \token ->
  token.replace (/_/g, '')

glyphIndex = {}
glyphIndex[derefGlyph]         = deref
glyphIndex[ignore!Glyph]       = ignore!
glyphIndex[quasiquoteGlyph]    = quasiquote
glyphIndex[quoteGlyph]         = quote
glyphIndex[spliceUnquoteGlyph] = spliceUnquote
glyphIndex[unquoteGlyph]       = unquote

binaryGlyphIndex = {}
binaryGlyphIndex[ignoreIfTrueGlyph]     = ignoreIfTrue
binaryGlyphIndex[ignoreUnlessTrueGlyph] = ignoreUnlessTrue

string?    = startsWith? '"'
identifer? = startsWith? ':'

module.exports = parse
