{ car }                       = require './linked-list'
{ cdr }                       = require './linked-list'
{ circumpendQuotes }          = require './js-utilities'
{ concat }                    = require './linked-list'
{ createErlAtom }             = require './type-utilities'
{ createErlBoolean }          = require './type-utilities'
{ createErlCorePureFunction } = require './type-utilities'
{ createErlIndex }            = require './type-utilities'
{ createErlList }             = require './type-utilities'
{ createErlNumber }           = require './type-utilities'
{ createErlString }           = require './type-utilities'
{ createErlSymbol }           = require './type-utilities'
{ drop }                      = require './linked-list'
{ empty? }                    = require './linked-list'
{ equal? }                    = require './linked-list'
{ extractJsValue }            = require './type-utilities'
{ fromArray }                 = require './linked-list'
interpret                     = require './interpret'
{ last }                      = require './linked-list'
{ erlAtom? }                  = require './type-utilities'
{ erlCorePureFunction? }      = require './type-utilities'
{ erlBoolean? }               = require './type-utilities'
{ erlFalse }                  = require './type-utilities'
{ erlFalse? }                 = require './type-utilities'
{ erlIgnore }                 = require './type-utilities'
{ erlIndex? }                 = require './type-utilities'
{ erlList? }                  = require './type-utilities'
{ erlMacro? }                 = require './type-utilities'
{ erlNil }                    = require './type-utilities'
{ erlNil? }                   = require './type-utilities'
{ erlNumber? }                = require './type-utilities'
{ erlString? }                = require './type-utilities'
{ erlSymbol? }                = require './type-utilities'
{ erlTrue }                   = require './type-utilities'
{ erlTrue? }                  = require './type-utilities'
{ erlUserPureFunction? }      = require './type-utilities'
{ next }                      = require './linked-list'
{ recurse }                   = require './linked-list'
{ reduce }                    = require './linked-list'
{ reverse }                   = require './linked-list'
serialize                     = require './serialize'
{ take }                      = require './linked-list'
{ toArray }                   = require './linked-list'
{ toPartialArray }            = require './linked-list'

append = \erlArgs ->
  [erlList, erlValues...] = toArray erlArgs
  concat (erlList, (fromArray erlValues))

areEqual = \erlArgs ->
  [erlValue0, erlValue1] = toPartialArray (2, erlArgs)
  _areEqual = (erlValue0, erlValue1) ->
    if erlList? erlValue0 && erlList? erlValue1
      equal? (erlValue0, erlValue1, _areEqual)
    else if erlIndex? erlValue0 && erlIndex? erlValue1
      jsIndex0 = erlValue0.jsValue
      jsIndex1 = erlValue1.jsValue
      (_areEqual ((keys jsIndex0), (keys jsIndex1))) &&
        (_areEqual ((vals jsIndex0), (vals jsIndex1)))
    else
      erlValue0.jsValue == erlValue1.jsValue
  createErlBoolean (_areEqual (erlValue0, erlValue1))

assoc = \erlArgs ->
  jsIndex = extractJsValue (car erlArgs)
  args = cdr erlArgs
  copy = {}
  for own key, value of jsIndex
    copy[key] = value
  until empty? args
    k = car args
    v = next args
    args = recurse (recurse args)
    copy[(extractJsValue k)] = v
  createErlIndex copy

atom = \erlArgs -> createErlAtom (car erlArgs)

_car = \erlArgs ->
  arg = car erlArgs
  if erlList? arg then car arg else erlNil

_cdr = \erlArgs ->
  arg = car erlArgs
  if erlList? arg then cdr arg else erlNil

_concat = \erlArgs ->
  erlLists = toArray erlArgs
  concat erlLists...

cons = \erlArgs ->
  createErlList (
    car erlArgs
    next erlArgs)

count = \erlArgs ->
  erlList = car erlArgs
  return erlNil unless erlList? erlList
  _reduce = (sum, value) -> sum + 1
  createErlNumber (reduce (0, _reduce, (car erlArgs)))

createPredicate = \pred \jsList ->
  erlValue = jsList.value
  createErlBoolean (pred erlValue)

deref = \erlArgs ->
  (car erlArgs).erlValue

_drop = \erlArgs ->
  [erlNumber, erlList] = toPartialArray (2, erlArgs)
  drop ((extractJsValue erlNumber), erlList)

_empty? = \erlArgs ->
  if empty? erlArgs
    erlFalse
  else
    if empty? (car erlArgs) then erlTrue else erlFalse

first = \erlArgs ->
  car (car erlArgs)

function? = \jsList ->
  erlValue = jsList.value
  createErlBoolean (erlCorePureFunction? erlValue || erlUserPureFunction? erlValue)

getEnvironment = \config ->
  { environment } = config
  setCoreFnsOnErlValues! (environment, functionsOnErlValues)
  return environment

ignore! = \erlArgs -> erlIgnore

ignoreIfTrue = \erlArgs ->
  [erlBool, erlValue] = toPartialArray (2, erlArgs)
  if (extractJsValue erlBool) then erlIgnore else erlValue

ignoreUnlessTrue = \erlArgs ->
  [erlBool, erlValue] = toPartialArray (2, erlArgs)
  if (extractJsValue erlBool) then erlValue else erlIgnore

_interpret = \erlArgs ->
  interpret (stripQuotes (extractJsValue (car erlArgs)))

_last = \erlArgs ->
  arg = car erlArgs
  if erlList? arg then last arg else erlNil

list = \erlArgs ->
  erlArgs

meta = \erlArgs ->
  erlMeta = (car erlArgs).meta
  if ? erlMeta then erlMeta else erlNil

_not = \erlArgs ->
  erlVal = car erlArgs
  if erlNil? erlVal || erlFalse? erlVal then erlTrue else erlFalse

nth = \erlArgs ->
  [erlNumber, erlList] = toPartialArray (2, erlArgs)
  for i in [0 ... (extractJsValue erlNumber)]
    erlList = cdr erlList
  car erlList

prepend = \erlArgs ->
  [erlList, erlValues...] = toArray erlArgs
  _reduce = (list, val) ->
    createErlList (val, list)
  erlValues.reduce (_reduce, erlList)

# WET; cf. 'env2.cough'.
_prStr = (erlArgs, printReadably?) ->
  ((toArray erlArgs)
    .map \erlArg -> serialize (erlArg, printReadably?))
    .join ''

prettyString = \erlArgs ->
  createErlString (circumpendQuotes (_prStr (erlArgs, true)))

_quit_ = ->
  process.exit 0

read = \jsList ->
  _read = \erlArgs ->
    jsFileName = stripQuotes (extractJsValue (car erlArgs))
    require('fs').readFileSync(jsFileName).toString()
  createErlString (_read jsList)

reset = \erlArgs ->
  [atom, value] = toPartialArray (2, erlArgs)
  atom.erlValue = value
  atom

rest = \erlArgs ->
  arg = car erlArgs
  if erlList? arg then cdr arg else erlNil

_reverse = \erlArgs ->
  arg = car erlArgs
  if erlList? arg then reverse arg else erlNil

set = \erlArgs ->
  [index, key, val] = toPartialArray (3, erlArgs)
  (extractJsValue index)[extractJsValue key] = val
  index

setCoreFnsOnErlValues! = (env, fns) ->
  for own fnName, fn of fns
    env[fnName] = createErlCorePureFunction fn 

slurp = \erlArgs ->
  jsFileName = stripQuotes (extractJsValue (car erlArgs))
  createErlString (
    circumpendQuotes (
      require('fs').readFileSync(jsFileName).toString()))

string = \erlArgs ->
  createErlString (circumpendQuotes (_prStr (erlArgs, false)))

stripQuotes = \jsString ->
  jsString[1 .. -2]

symbol = \erlArgs ->
  erlValue = car erlArgs
  if erlString? erlValue
    jsStr = extractJsValue erlValue
    createErlSymbol jsStr[1 ... -1]
  else
    erlNil

_take = \erlArgs ->
  [erlNumber, erlList] = toPartialArray (2, erlArgs)
  take ((extractJsValue erlNumber), erlList)

typeOf = \erlArgs ->
  erlValue = car erlArgs
  createErlString (circumpendQuotes erlValue.type)

_throw = \erlArgs ->
  throw (car erlArgs)

time-ms = () ->
  createErlNumber (new Date().getTime ())

withMeta = \erlArgs ->
  [erlVal, erlMeta] = toPartialArray (2, erlArgs)
  if erlAtom? erlVal
    { erlValue, type } = erlVal
    { erlValue, type, meta: erlMeta }
  else
    { jsValue, type } = erlVal
    { jsValue, type, meta: erlMeta }

write = \erlArgs ->
  createErlString (serialize (car erlArgs))

[atom?, boolean?, coreFn?, false?, list?, macro?, nil?, number?, symbol?, string?, userFn?, true?] =
  [ erlAtom?
    erlBoolean?
    erlCorePureFunction?
    erlFalse?
    erlList?
    erlMacro?
    erlNil?
    erlNumber?
    erlSymbol?
    erlString?
    erlUserPureFunction?
    erlTrue?
  ].map createPredicate

functionsOnErlValues = {
  '='                  : areEqual
  'append'             : append
  'assoc'              : assoc
  'atom'               : atom
  'atom?'              : atom?
  'boolean?'           : boolean?
  'car'                : _car
  'cdr'                : _cdr
  'cons'               : cons
  'concat'             : _concat
  'core-fn?'           : coreFn?
  'count'              : count
  'deref'              : deref
  'drop'               : _drop
  'empty?'             : _empty?
  'first'              : _car
  'false?'             : false?
  'function?'          : function?
  'ignore!'            : ignore!
  'ignoreIfTrue'       : ignoreIfTrue
  'ignoreUnlessTrue'   : ignoreUnlessTrue
  'last'               : _last
  'list'               : list
  'list?'              : list?
  'macro?'             : macro?
  'meta'               : meta
  'nil?'               : nil?
  'not'                : _not
  'nth'                : nth
  'number?'            : number?
  'parse'              : _interpret
  'prepend'            : prepend
  'pretty-string'      : prettyString
  'rest'               : _cdr
  'reverse'            : _reverse
  'string'             : string
  'string?'            : string?
  'symbol'             : symbol
  'symbol?'            : symbol?
  'take'               : _take
  'throw'              : _throw
  'true?'              : true?
  'typeof'             : typeOf
  'user-fn?'           : userFn?

  # Effects:
  '-quit-'             : _quit_
  'read'               : read
  'reset!'             : reset
  'set!'               : set
  'slurp'              : slurp
  'time-ms'            : time-ms
  'with-meta'          : withMeta
  'write'              : write
}

module.exports = getEnvironment
