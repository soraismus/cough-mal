{ circumpendQuotes } = require './js-utilities'
{ createMalString }  = require './type-utilities'
{ fromArray }        = require './linked-list'
getLispEnvironment   = require './getLispEnvironment'
_process             = require './_process'
_serialize           = require './serialize'
standardFnsAndMacros = require './standard-fns-and-macros'
tokenizeAndParse     = require './tokenizeAndParse'

_createMalString = \jsString ->
  createMalString (circumpendQuotes jsString)

encapsulate = \type \malValue ->
  { effect: { type }, value: malValue }

error = \errorMessage ->
  [encapsulate 'error' "repl error: (#{errorMessage})"]

flattenIfNecessary = \effects ->
  result = effects
  while result.length == 1 && Array.isArray (value = result[0].value)
    result = flattenIfNecessary value
  result

_interpret = (envs, jsString) ->
  try serialize (flattenIfNecessary (_process tokenizeAndParse envs jsString))
  catch e
    error e

interpret = (jsString, userJsArray) ->
  if ? userJsArray
    userEnv = { '*ARGV*' : fromArray (userJsArray.map _createMalString) }
    _interpret ([userEnv, environment], jsString)
  else
    _interpret ([environment], jsString)

serialize = \results ->
  results.map \result ->
    _result = {}
    for own key, value of result
      if key == 'effect'
        _result[key] = value
      else
        _result[key] = _serialize value
    _result

environment = getLispEnvironment { display: encapsulate 'display' }

interpret standardFnsAndMacros

module.exports = interpret
