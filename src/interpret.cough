{ circumpendQuotes } = require './js-utilities'
{ createMalString }  = require './type-utilities'
{ fromArray }        = require './linked-list'
getLispEnvironment   = require './getLispEnvironment'
_process             = require './process'
_serialize           = require './serialize'
standardFnsAndMacros = require './standard-fns-and-macros'

_createMalString = \jsString ->
  createMalString (circumpendQuotes jsString)

display = \malValue ->
  { effect: { type: 'display' }, value: malValue }

_interpret = (envs, jsString) ->
  try serialize (_process envs jsString)
  catch e
    "repl error: (#{serialize e} + )"

interpret = (jsString, userJsArray) ->
  if ? userJsArray
    userEnv = { '*ARGV*' : fromArray (userJsArray.map _createMalString) }
    _interpret ([userEnv, environment], jsString)
  else
    _interpret ([environment], jsString)

serialize = \results ->
  results.map \result ->
    _result = {}
    for own key, value of result
      if key == 'effect'
        _result[key] = value
      else
        _result[key] = _serialize value
    _result

environment = getLispEnvironment display

interpret standardFnsAndMacros

module.exports = interpret
