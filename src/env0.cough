{ createErlBoolean }          = require './type-utilities'
{ createErlCorePureFunction } = require './type-utilities'
{ createErlIdentifier }       = require './type-utilities'
{ createErlIndex }            = require './type-utilities'
{ createErlNumber }           = require './type-utilities'
{ createErlString }           = require './type-utilities'
{ extractJsValue }            = require './type-utilities'
{ fromArray }                 = require './linked-list'
{ jsNaN? }                    = require './js-utilities'
{ jsNumber? }                 = require './js-utilities'
{ jsString? }                 = require './js-utilities'
{ erlNil }                    = require './type-utilities'
{ reduce }                    = require './linked-list'
{ toArray }                   = require './linked-list'

add = (nbrs...) ->
  createErlNumber (nbrs.reduce ((x, nbr) ->  x += nbr))

contains? = (index, key) -> createErlBoolean (key of index)

dissoc = (index, keys...) ->
  copy = {}
  for own key, value of index
    copy[key] = value
  delete copy[key] for key in keys
  createErlIndex copy

divide = (nbrs...) ->
  createErlNumber (nbrs.reduce ((x, nbr) -> x /= nbr))

exponentiate = (nbrs...) ->
  createErlNumber (nbrs.reduce ((x, nbr) -> Math.pow (x, nbr)))

get = (jsIndex, jsKey) -> jsIndex[jsKey]

getEnvironment = \config ->
  { environment } = config
  setCoreFnsOnJsValues! (environment, functionsOnJsValues)
  return environment

greaterThanOrEqual = (nbrs...) ->
  createErlBoolean (nbrs[0] >= nbrs[1])

greaterThan = (nbrs...) ->
  createErlBoolean (nbrs[0] > nbrs[1])

index = (args...) ->
  index = {}
  index[k] = args[i + 1] for k, i in args when i % 2 == 0
  createErlIndex index

keys = \index ->
  _keys = []
  for own key, value of index
    _keys.push (
      if jsNaN? (jsNbr = parseFloat (key, 10))
        (if key[0] == ':'           then createErlIdentifier else createErlString) key
      else
        createErlNumber jsNbr)
  fromArray _keys

length = \jsVal ->
  return erlNil unless jsString? jsVal
  createErlNumber (jsVal.length - 2)

lessThan = (nbrs...) ->
  createErlBoolean (nbrs[0] < nbrs[1])
  
lessThanOrEqual = (nbrs...) ->
  createErlBoolean (nbrs[0] <= nbrs[1])

lift = (fnOnJsValues) -> (erlValueList) ->
  fnOnJsValues (((toArray erlValueList).map extractJsValue)...)

max = (nbrs...) ->
  createErlNumber (Math.max (nbrs...))

min = (nbrs...) ->
  createErlNumber (Math.min (nbrs...))

mod = (nbr0, nbr1) ->
  createErlNumber (nbr0 % nbr1)

multiply = (nbrs...) ->
  createErlNumber (nbrs.reduce ((x, nbr) -> x *= nbr))

negate = \nbr ->
  createErlNumber (-1 * nbr)

parseNumber = \jsVal ->
  return jsVal if jsNumber? jsVal
  return erlNil unless jsString? jsVal
  jsNbr = parseFloat ((stripQuotes jsVal), 10)
  if jsNaN? jsNbr           then erlNil else createErlNumber jsNbr

setCoreFnsOnJsValues! = (env, fns) ->
  for own fnName, fn of fns
    env[fnName] = createErlCorePureFunction (lift fn)

subtract = (nbrs...) ->
  createErlNumber (nbrs.reduce ((x, nbr) -> x -= nbr))

vals = \index ->
  values = []
  for own key, value of index
    values.push value
  fromArray values

functionsOnJsValues = {
  '+'            : add
  'contains?'    : contains?
  'dissoc'       : dissoc
  '/'            : divide
  '**'           : exponentiate
  'get'          : get
  '>'            : greaterThan
  '>='           : greaterThanOrEqual
  'index'        : index
  'keys'         : keys
  'length'       : length
  'max'          : max
  'min'          : min
  '<'            : lessThan
  '<='           : lessThanOrEqual
  '%'            : mod
  '*'            : multiply
  'negate'       : negate
  'parse-number' : parseNumber
  '-'            : subtract
  'vals'         : vals
}

module.exports = getEnvironment
