{ erlTypes } = require './types'

erlListType = erlTypes[6]

car = \erlList ->
  if empty? erlList
    EOL
  else
    erlList.value

cdr = \erlList ->
  if empty? erlList
    EOL
  else
    erlList.next

concat = (erlLists...) ->
  return EOL if erlLists.length == 0
  result = copy erlLists[0]
  tail = lastTail result
  for erlList in erlLists[1 .. ]
    _copy = copy erlList
    if empty? tail
      result = _copy
      tail = lastTail result
      continue
    unless empty? _copy
      tail.next = _copy
      tail = lastTail _copy
  result

cons = \erlArgs ->
  createErlList (
    car erlArgs
    next erlArgs)

copy = \erlList ->
  map ((\x -> x), erlList)

createErlList = (value, nextNode) ->
  return EOL unless ? value
  createNode (value, nextNode ?? EOL)

createNode = (value, nextNode) ->
  { type: erlListType, value, next : nextNode }

drop = (nbr, erlList) ->
  until nbr == 0
    erlList = cdr erlList
    nbr = nbr - 1
  erlList

empty? = \value ->
  value == EOL

equal? = (list0, list1, equivalent?) ->
  until empty? list0 || empty? list1
    return false unless equivalent? (list0.value, list1.value)
    list0 = cdr list0
    list1 = cdr list1
  empty? list0 && empty? list1

filter = (predicate, list) ->
  _reduce = (list, value) ->
    if predicate value
      createErlList (value, list)
    else
      list
  reverse (reduce (EOL, _reduce, list))

forEach = (fn, list) ->
  result = list
  until empty? list
    result = fn list.value
    list = recurse list
  result

last = \erlList ->
  car (lastTail erlList)

lastTail = \erlList ->
  return erlList if empty? erlList
  prior = erlList
  current = cdr erlList
  until empty? current
    prior = cdr prior
    current = cdr current
  prior

map = (fn, list) ->
  _reduce = (list, value) ->
    createErlList ((fn value), list)
  reverse (reduce (EOL, _reduce, list))

next = \erlList ->
  car (cdr erlList)

recurse = \list ->
  if empty? list then list else list.next

reduce = (seed, fn, list) ->
  until empty? list
    seed = fn (seed, list.value)
    list = recurse list
  seed

reduceBy2 = (seed, fn, list) ->
  until empty? list
    value0 = list.value
    list = recurse list
    value1 = list.value
    seed = fn (seed, value0, value1)
    list = recurse list
  seed

reverse = \list ->
  result = EOL
  until empty? list
    result = createErlList (list.value, result)
    list = list.next
  result

take = (nbr, erlList) ->
  result = createErlList ()
  until nbr == 0
    node = car erlList
    erlList = cdr erlList
    result = createErlList (node, result)
    nbr = nbr - 1
  return reverse result

toArray = \list ->
  _reduce = (jsArray, value) ->
    jsArray.push value
    jsArray
  reduce ([], _reduce, list)

fromArray = \array ->
  _reduce = (list, value) ->
    createErlList (value, list)
  array.reverse().reduce(_reduce, createErlList())

toPartialArray = (nbr, list) ->
  result = []
  until nbr == 0
    node = car list
    list = cdr list
    result.push node
    nbr = nbr - 1
  result.push list
  result

zip = (seed, fn, list0, list1) ->
  until empty? list0 || empty? list1
    value0 = car list0
    list0 = cdr list0
    value1 = car list1
    list1 = cdr list1
    seed = fn (seed, value0, value1)
  seed

_EOL = {}

EOL = createNode (_EOL, _EOL)

module.exports = {
  car
  cdr
  concat
  cons
  copy
  createErlList
  drop
  empty?
  equal?
  filter
  forEach
  fromArray
  last
  map
  next
  recurse
  reduce
  reduceBy2
  reverse
  take
  toArray
  toPartialArray
}
