{ addEnv }                    = require './env-utilities'
{ car }                       = require './linked-list'
{ catch* }                    = require './keyTokens'
{ cdr }                       = require './linked-list'
{ circumpendQuotes }          = require './js-utilities'
commentSignal                 = require './commentSignal'
{ createErlIndex }            = require './type-utilities'
{ createErlKeyword }          = require './type-utilities'
{ createErlList }             = require './type-utilities'
{ createErlMacro }            = require './type-utilities'
{ createErlNumber }           = require './type-utilities'
{ createErlString }           = require './type-utilities'
{ createErlSymbol }           = require './type-utilities'
{ createErlUserPureFunction } = require './type-utilities'
{ def! }                      = require './keyTokens'
{ _do }                       = require './keyTokens'
{ empty? }                    = require './linked-list' 
{ _eval }                     = require './keyTokens'
{ _evalWithEnv }              = require './keyTokens'
{ expand-macro }              = require './keyTokens'
{ extractJsValue }            = require './type-utilities'
{ filter }                    = require './linked-list'
{ fn* }                       = require './keyTokens'
{ forEach }                   = require './linked-list'
{ fromArray }                 = require './linked-list'
{ fromJsObjects }             = require './index-utilities'
{ fromErlIndex }              = require './index-utilities'
{ _getCurrentEnv }            = require './keyTokens'
{ _getDefaultEnv }            = require './keyTokens'
{ _if }                       = require './keyTokens'
{ jsString? }                 = require './js-utilities'
{ keyword? }                  = require './keyTokens'
{ let* }                      = require './keyTokens'
{ letrec* }                   = require './keyTokens'
{ lookup }                    = require './env-utilities'
{ macro* }                    = require './keyTokens'
{ erlCoreEffectfulFunction? } = require './type-utilities'
{ erlCorePureFunction? }      = require './type-utilities'
{ erlIgnore? }                = require './type-utilities'
{ erlIndex? }                 = require './type-utilities'
{ erlKeyword? }               = require './type-utilities'
{ erlList? }                  = require './type-utilities'
{ erlMacro? }                 = require './type-utilities'
{ erlNil }                    = require './type-utilities'
{ erlSymbol? }                = require './type-utilities'
{ erlUserPureFunction? }      = require './type-utilities'
{ map }                       = require './linked-list'
{ next }                      = require './linked-list'
{ quasiquote }                = require './keyTokens'
{ quote }                     = require './keyTokens'
{ spliceUnquote }             = require './keyTokens'
{ unquote }                   = require './keyTokens'
{ recurse }                   = require './linked-list'
{ reduce }                    = require './linked-list'
{ reduceBy2 }                 = require './linked-list'
{ reverse }                   = require './linked-list'
{ setMainEnv }                = require './env-utilities'
{ splat }                     = require './keyTokens'
{ toPartialArray }            = require './linked-list'
{ try* }                      = require './keyTokens'
{ undef! }                    = require './keyTokens'
{ unsetMainEnv }              = require './env-utilities'

createFn = (erlList, envs) ->
  createErlUserPureFunction
    localEnvs     : (envs.slice 0)
    erlExpression : (next erlList)
    erlParameters : (car erlList)

createLocalEnv = (erlParams, erlArgs) ->
  env = {}
  until empty? erlParams
    jsParam = extractJsValue (car erlParams)
    if jsParam == splat
      env[extractJsValue (next erlParams)] = erlArgs
      return env
    else
      env[jsParam] = car erlArgs
      erlParams = cdr erlParams
      erlArgs = cdr erlArgs
  env

createMacro = (erlList, envs) ->
  createErlMacro
    localEnvs     : (envs.slice 0)
    erlExpression : (next erlList)
    erlParameters : (car erlList)

defineNewValue = (erlList, envs, addResult) ->
  jsKey = extractJsValue (car erlList)
  erlValue = _evaluate ((next erlList), envs, addResult)
  setMainEnv (envs, jsKey, erlValue)

evalQuasiquotedExpr = (expr, envs, addResult) ->
  return expr unless erlList? expr
  manageItem = (memo, item) ->
    switch
      when unquotedExpr? item
        createErlList (_evaluate ((next item), envs, addResult), memo)
      when spliceUnquotedExpr? item
        _manageItem = (_memo, _item) ->
          createErlList (_item, _memo)
        reduce (memo, _manageItem, (_evaluate ((next item), envs, addResult)))
      when erlList? item
        createErlList (evalQuasiquotedExpr (item, envs, addResult), memo)
      else
        createErlList (item, memo)
  reverse(
    reduce (
      createErlList ()
      manageItem
      expr))

_evaluate = (erlExpr, envs, addResult) ->
  loop
    switch
      when erlSymbol? erlExpr
        jsString = extractJsValue erlExpr
        if keyword? jsString
          return createErlKeyword jsString
        else
          return lookup (envs, jsString)

      when erlIndex? erlExpr
        index = extractJsValue erlExpr
        newIndex = {}
        for own key, value of index
          newIndex[key] = _evaluate (index[key], envs, addResult)
        return createErlIndex newIndex

      when ! (erlList? erlExpr)
        return erlExpr

      else
        erlExpr = filter ((\x -> ! (ignorable? (x, envs, addResult))), erlExpr)
        [head, arg1, remainingArgs] = toPartialArray (2, erlExpr)
        tailList = cdr erlExpr

        switch (extractJsValue head)
          when def!
            return defineNewValue (tailList, envs, addResult) 

          when undef!
            return undefineValue (tailList, envs) 

          when _eval
            erlExpr = _evaluate (arg1, envs, addResult)

          when _evalWithEnv
            envs = [(fromErlIndex (_evaluate (arg1, envs, addResult)))]
            erlExpr = _evaluate ((car remainingArgs), envs, addResult)

          when let*
            erlExpr = (car remainingArgs)
            envs = addEnv (envs, reduceLet* (envs, arg1, addResult))

          when letrec*
            erlExpr = (car remainingArgs)
            envs = addEnv (envs, reduceLetrec* (envs, arg1, addResult))

          when _do
            return forEach ((evaluate (envs, addResult)), tailList)

          when _getCurrentEnv
            return fromJsObjects ((envs.reverse ())...)

          when _getDefaultEnv
            return fromJsObjects envs[envs.length - 1]

          when _if
            erlExpr =
              if extractJsValue (_evaluate (arg1, envs, addResult))
                (car remainingArgs)
              else
                if (empty? (otherwise = (next remainingArgs))) then erlNil else otherwise

          when fn*
            return createFn (tailList, envs)

          when macro*
            return createMacro (tailList, envs)

          when quote
            return car tailList

          when quasiquote
            return evalQuasiquotedExpr ((car tailList), envs, addResult)

          when expand-macro
            return expandMacro ((car arg1), (cdr arg1), envs, addResult)

          when try*
            try
              return _evaluate (arg1, envs, addResult)
            catch ex
              if empty? remainingArgs
                throw ex
              else
                [_catch, _ex, catchExpr] = toPartialArray (3, (car remainingArgs))
                throw ex if (extractJsValue _catch) != "catch*"
                if ex instanceof Error
                  ex = createErlString (circumpendQuotes ex.message)
                newEnv = {}
                newEnv[extractJsValue _ex] = ex
                return _evaluate (catchExpr, addEnv (envs, newEnv), addResult)

          else
            erlSymbol = head
            erlExpr = tailList

            erlInvokable = _evaluate (erlSymbol, envs, addResult)

            switch
              when erlKeyword? erlInvokable
                erlExpr = createErlList (erlInvokable, tailList)

              when erlMacro? erlInvokable
                erlExpr = expandMacro (head, tailList, envs, addResult)

              when erlCorePureFunction? erlInvokable
                fn = extractJsValue erlInvokable
                erlArgs = map ((evaluate (envs, addResult)), erlExpr)
                return fn erlArgs

              when erlCoreEffectfulFunction? erlInvokable
                fn = extractJsValue erlInvokable
                erlArgs = map ((evaluate (envs, addResult)), erlExpr)
                addResult (fn erlArgs)
                return erlNil

              when erlUserPureFunction? erlInvokable
                { localEnvs, erlExpression, erlParameters } =
                  extractJsValue erlInvokable

                erlArgs = map ((evaluate (envs, addResult)), erlExpr)
                erlExpr = erlExpression
                newEnv = createLocalEnv (erlParameters, erlArgs)
                envs = addEnv (localEnvs, newEnv)

              else
                #throw 'Value is not a function'
                throw "#{extractJsValue erlSymbol} does not evaluate to a function, macro, or keyword."

evaluate = (envs, addResult) -> (erlExpr) ->
  return commentSignal if erlExpr == commentSignal
  _evaluate (erlExpr, envs, addResult)

expandMacro = (erlMacroSymbol, erlArgs, envs, addResult) ->
  erlMacro = _evaluate (erlMacroSymbol, envs, addResult)
  { localEnvs, erlExpression, erlParameters } = extractJsValue erlMacro
  newEnv = createLocalEnv (erlParameters, erlArgs)
  newEnvStack = addEnv (localEnvs, newEnv)
  _evaluate (erlExpression, newEnvStack, addResult)

ignorable? = (erlVal, envs, addResult) ->
  erlIgnore? erlVal ||
    (erlList? erlVal && erlSymbol? (symbol = car erlVal) && (
      ((jsString = extractJsValue symbol) == 'ignore!') ||
      ((jsString == 'ignoreIfTrue') && (extractJsValue (_evaluate ((next erlVal), envs, addResult)))) ||
      ((jsString == 'ignoreUnlessTrue') && ! (extractJsValue (_evaluate ((next erlVal), envs, addResult))))))

reduceLet* = (envs, list, addResult) ->
  newEnv = {}
  _envs = addEnv (envs, newEnv)
  until empty? list
    jsKey = extractJsValue list.value
    list = recurse list
    envValue = _evaluate (list.value, _envs, addResult)
    newEnv[jsKey] = envValue
    list = recurse list
  newEnv

reduceLetrec* = (envs, list, addResult) ->
  newEnv = {}
  _envs = addEnv (envs, newEnv)
  until empty? list
    jsKey = extractJsValue list.value
    list = recurse list

    _erlExpr = fromArray ([
      createErlSymbol "fix*"
      fromArray ([
        createErlSymbol "fn*"
        fromArray ([jsKey])
        list.value
      ])
    ])

    envValue = _evaluate (_erlExpr, _envs, addResult)
    newEnv[jsKey] = envValue
    list = recurse list
  newEnv

spliceUnquote? = \erlValue ->
  spliceUnquote == (extractJsValue erlValue)

spliceUnquotedExpr? = \erlValue ->
  erlList? erlValue && (spliceUnquote? (car erlValue))

undefineValue = (erlList, envs) ->
  jsKey = extractJsValue (car erlList)
  unsetMainEnv (envs, jsKey)

unquote? = \erlValue ->
  unquote == (extractJsValue erlValue)

unquotedExpr? = \erlValue ->
  erlList? erlValue && (unquote? (car erlValue))

module.exports = evaluate
