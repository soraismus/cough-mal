{ addEnv }                    = require './env-utilities'
{ car }                       = require './linked-list'
{ catch* }                    = require './keyTokens'
{ cdr }                       = require './linked-list'
{ circumpendQuotes }          = require './js-utilities'
commentSignal                 = require './commentSignal'
{ createMalIndex }            = require './type-utilities'
{ createMalKeyword }          = require './type-utilities'
{ createMalList }             = require './type-utilities'
{ createMalMacro }            = require './type-utilities'
{ createMalNumber }           = require './type-utilities'
{ createMalString }           = require './type-utilities'
{ createMalSymbol }           = require './type-utilities'
{ createMalUserPureFunction } = require './type-utilities'
{ def! }                      = require './keyTokens'
{ _do }                       = require './keyTokens'
{ empty? }                    = require './linked-list' 
{ expand-macro }              = require './keyTokens'
{ extractJsValue }            = require './type-utilities'
{ filter }                    = require './linked-list'
{ fn* }                       = require './keyTokens'
{ forEach }                   = require './linked-list'
{ fromArray }                 = require './linked-list'
{ fromJsObjects }             = require './index-utilities'
{ _getCurrentEnv }            = require './keyTokens'
{ _getDefaultEnv }            = require './keyTokens'
{ _if }                       = require './keyTokens'
{ jsString? }                 = require './js-utilities'
{ keyword? }                  = require './keyTokens'
{ let* }                      = require './keyTokens'
{ letrec* }                   = require './keyTokens'
{ lookup }                    = require './env-utilities'
{ macro* }                    = require './keyTokens'
{ malCoreEffectfulFunction? } = require './type-utilities'
{ malCorePureFunction? }      = require './type-utilities'
{ malIgnore? }                = require './type-utilities'
{ malIndex? }                 = require './type-utilities'
{ malList? }                  = require './type-utilities'
{ malMacro? }                 = require './type-utilities'
{ malNil }                    = require './type-utilities'
{ malSymbol? }                = require './type-utilities'
{ malUserPureFunction? }      = require './type-utilities'
{ map }                       = require './linked-list'
{ next }                      = require './linked-list'
{ quasiquote }                = require './keyTokens'
{ quote }                     = require './keyTokens'
{ spliceUnquote }             = require './keyTokens'
{ unquote }                   = require './keyTokens'
{ recurse }                   = require './linked-list'
{ reduce }                    = require './linked-list'
{ reduceBy2 }                 = require './linked-list'
{ reverse }                   = require './linked-list'
{ setMainEnv }                = require './env-utilities'
{ splat }                     = require './keyTokens'
{ toPartialArray }            = require './linked-list'
{ try* }                      = require './keyTokens'
{ undef! }                    = require './keyTokens'
{ unsetMainEnv }              = require './env-utilities'

createFn = (malList, envs) ->
  createMalUserPureFunction
    localEnvs     : (envs.slice 0)
    malExpression : (next malList)
    malParameters : (car malList)

createLocalEnv = (malParams, malArgs) ->
  env = {}
  until empty? malParams
    jsParam = extractJsValue (car malParams)
    if jsParam == splat
      env[extractJsValue (next malParams)] = malArgs
      return env
    else
      env[jsParam] = car malArgs
      malParams = cdr malParams
      malArgs = cdr malArgs
  env

createMacro = (malList, envs) ->
  createMalMacro
    localEnvs     : (envs.slice 0)
    malExpression : (next malList)
    malParameters : (car malList)

defineNewValue = (malList, envs, addResult) ->
  jsKey = extractJsValue (car malList)
  malValue = _evaluate ((next malList), envs, addResult)
  setMainEnv (envs, jsKey, malValue)

evalQuasiquotedExpr = (expr, envs, addResult) ->
  return expr unless malList? expr
  manageItem = (memo, item) ->
    switch
      when unquotedExpr? item
        createMalList (_evaluate ((next item), envs, addResult), memo)
      when spliceUnquotedExpr? item
        _manageItem = (_memo, _item) ->
          createMalList (_item, _memo)
        reduce (memo, _manageItem, (_evaluate ((next item), envs, addResult)))
      when malList? item
        createMalList (evalQuasiquotedExpr (item, envs, addResult), memo)
      else
        createMalList (item, memo)
  reverse(
    reduce (
      createMalList ()
      manageItem
      expr))

_evaluate = (malExpr, envs, addResult) ->
  loop
    switch
      when malSymbol? malExpr
        jsString = extractJsValue malExpr
        if keyword? jsString
          return createMalKeyword jsString
        else
          return lookup (envs, jsString)

      when malIndex? malExpr
        index = extractJsValue malExpr
        newIndex = {}
        for own key, value of index
          newIndex[key] = _evaluate (index[key], envs, addResult)
        return createMalIndex newIndex

      when ! (malList? malExpr)
        return malExpr

      else
        malExpr = filter ((\x -> ! (ignorable? (x, envs, addResult))), malExpr)
        [head, arg1, remainingArgs] = toPartialArray (2, malExpr)
        tailList = cdr malExpr

        switch (extractJsValue head)
          when def!
            return defineNewValue (tailList, envs, addResult) 

          when undef!
            return undefineValue (tailList, envs) 

          when let*
            malExpr = (car remainingArgs)
            envs = addEnv (envs, reduceLet* (envs, arg1, addResult))

          when letrec*
            malExpr = (car remainingArgs)
            envs = addEnv (envs, reduceLetrec* (envs, arg1, addResult))

          when _do
            return forEach ((evaluate (envs, addResult)), tailList)

          when _getCurrentEnv
            return fromJsObjects ((envs.reverse ())...)

          when _getDefaultEnv
            return fromJsObjects envs[envs.length - 1]

          when _if
            malExpr =
              if extractJsValue (_evaluate (arg1, envs, addResult))
                (car remainingArgs)
              else
                if (empty? (otherwise = (next remainingArgs))) then malNil else otherwise

          when fn*
            return createFn (tailList, envs)

          when macro*
            return createMacro (tailList, envs)

          when quote
            return car tailList

          when quasiquote
            return evalQuasiquotedExpr ((car tailList), envs, addResult)

          when expand-macro
            return expandMacro ((car arg1), (cdr arg1), envs, addResult)

          when try*
            try
              return _evaluate (arg1, envs, addResult)
            catch ex
              if empty? remainingArgs
                throw ex
              else
                [_catch, _ex, catchExpr] = toPartialArray (3, (car remainingArgs))
                throw ex if (extractJsValue _catch) != "catch*"
                if ex instanceof Error
                  ex = createMalString (circumpendQuotes ex.message)
                newEnv = {}
                newEnv[extractJsValue _ex] = ex
                return _evaluate (catchExpr, addEnv (envs, newEnv), addResult)

          else
            malSymbol = head
            malExpr = tailList

            malInvokable = _evaluate (malSymbol, envs, addResult)

            switch
              when malMacro? malInvokable
                malExpr = expandMacro (head, tailList, envs, addResult)

              when malCorePureFunction? malInvokable
                fn = extractJsValue malInvokable
                malArgs = map ((evaluate (envs, addResult)), malExpr)
                return fn malArgs

              when malCoreEffectfulFunction? malInvokable
                fn = extractJsValue malInvokable
                malArgs = map ((evaluate (envs, addResult)), malExpr)
                addResult (fn malArgs)
                return malNil

              when malUserPureFunction? malInvokable
                { localEnvs, malExpression, malParameters } =
                  extractJsValue malInvokable

                malArgs = map ((evaluate (envs, addResult)), malExpr)
                malExpr = malExpression
                newEnv = createLocalEnv (malParameters, malArgs)
                envs = addEnv (localEnvs, newEnv)

              else
                throw 'Value is not a function'

evaluate = (envs, addResult) -> (malExpr) ->
  return commentSignal if malExpr == commentSignal
  _evaluate (malExpr, envs, addResult)

expandMacro = (malMacroSymbol, malArgs, envs, addResult) ->
  malMacro = _evaluate (malMacroSymbol, envs, addResult)
  { localEnvs, malExpression, malParameters } = extractJsValue malMacro
  newEnv = createLocalEnv (malParameters, malArgs)
  newEnvStack = addEnv (localEnvs, newEnv)
  _evaluate (malExpression, newEnvStack, addResult)

ignorable? = (malVal, envs, addResult) ->
  malIgnore? malVal ||
    (malList? malVal && malSymbol? (symbol = car malVal) && (
      ((jsString = extractJsValue symbol) == 'ignore!') ||
      ((jsString == 'ignoreIfTrue') && (extractJsValue (_evaluate ((next malVal), envs, addResult)))) ||
      ((jsString == 'ignoreUnlessTrue') && ! (extractJsValue (_evaluate ((next malVal), envs, addResult))))))

reduceLet* = (envs, list, addResult) ->
  newEnv = {}
  _envs = addEnv (envs, newEnv)
  until empty? list
    jsKey = extractJsValue list.value
    list = recurse list
    envValue = _evaluate (list.value, _envs, addResult)
    newEnv[jsKey] = envValue
    list = recurse list
  newEnv

reduceLetrec* = (envs, list, addResult) ->
  newEnv = {}
  _envs = addEnv (envs, newEnv)
  until empty? list
    jsKey = extractJsValue list.value
    list = recurse list

    _malExpr = fromArray ([
      createMalSymbol "fix*"
      fromArray ([
        createMalSymbol "fn*"
        fromArray ([jsKey])
        list.value
      ])
    ])

    envValue = _evaluate (_malExpr, _envs, addResult)
    newEnv[jsKey] = envValue
    list = recurse list
  newEnv

spliceUnquote? = \malValue ->
  spliceUnquote == (extractJsValue malValue)

spliceUnquotedExpr? = \malValue ->
  malList? malValue && (spliceUnquote? (car malValue))

undefineValue = (malList, envs) ->
  jsKey = extractJsValue (car malList)
  unsetMainEnv (envs, jsKey)

unquote? = \malValue ->
  unquote == (extractJsValue malValue)

unquotedExpr? = \malValue ->
  malList? malValue && (unquote? (car malValue))

module.exports = evaluate
