(do

  (def! fix*
    (fn* (f)
      ( (fn* (x) (f (fn* (& ys) (apply (x x) ys))))
        (fn* (x) (f (fn* (& ys) (apply (x x) ys)))))))

  (def! memfix
    (fn* (f)
      (let* (cache {})
        (
          (fn* (x cache)
            (f
              (fn* (z)
                (if (contains? cache z)
                  (get cache z)
                  (let* (result ((fn* (y) ((x x cache) y)) z))
                    (do (set! cache z result) result))))
              cache))
          (fn* (x cache)
            (f
              (fn* (z)
                (if (contains? cache z)
                  (get cache z)
                  (let* (result ((fn* (y) ((x x cache) y)) z))
                    (do (set! cache z result) result))))
              cache))
          cache))))

  (def! 1st car)
  (def! 2nd (fn* (xs) (nth 1 xs)))
  (def! 3rd (fn* (xs) (nth 2 xs)))

  (def! swap! (macro* (atom & xs)
    (if (empty? xs)
      atom
      `(let* (-atom- ~atom)
        (do
          (reset! -atom- (~(car xs) (deref -atom-) ~@(cdr xs)))
          (deref -atom-))))))

  (def! *gensym-counter* (atom 0))
  (def! gensym (fn* ()
    (symbol (str "G__" (swap! *gensym-counter* incr)))))

  (def! or (macro* (& xs)
    (if (empty? xs)
      false
      (let* (-query- (gensym))
        `(let* (~-query- ~(car xs))
          (if ~-query- 
            ~-query-
            (or ~@(cdr xs))))))))

  (def! and (macro* (& xs)
    (if (empty? xs)
      true
      `(let* (-query- ~(car xs))
        (if -query-
          (and ~@(cdr xs))
          false)))))

  (def! cond (macro* (& xs)
    (if (or (empty? xs) (empty? (cdr xs)))
      nil
      `(let* (-query- ~(car xs))
        (if -query-
          ~(2nd xs)
          (cond ~@(cdr (cdr xs))))))))

  (def! -> (macro* (& xs)
    (if (empty? xs)
      nil
      (let* (x  (car xs)
             xs (cdr xs))
        (if (empty? xs)
          x
          (let* (form  (car xs)
                 forms (cdr xs))
            (if (empty? forms)
              (if (list? form)
                (if (= (symbol "fn*") (car form))
                  `(~form ~x)
                  `(~(car form) ~x ~@(cdr form)))
                (list form x))
              `(-> (-> ~x ~form) ~@forms))))))))

  (def! ->> (macro* (& xs)
    (if (empty? xs)
      nil
      (let* (x  (car xs)
             xs (cdr xs))
        (if (empty? xs)
          x
          (let* (form  (car xs)
                 forms (cdr xs))
            (if (empty? forms)
              (if (list? form)
                (if (= (symbol "fn*") (car form))
                  `(~form ~x)
                  `(~@form  ~x))
                (list form x))
              `(->> (->> ~x ~form) ~@forms))))))))

  (def! ->* (macro* (& xs) `(fn* (-x-) (-> -x- ~@xs))))

  (def! ->>* (macro* (& xs) `(fn* (-x-) (->> -x- ~@xs))))

  (def! incr  (->* (+ 1)))
  (def! decr  (->* (- 1)))
  (def! zero? (->* (= 0)))

  (def! not (fn* (x) (if x false true)))

  (def! identity (fn* (x) x))

  (def! constant-fn (fn* (x) (fn* (y) x)))

  (def! call-on (fn* (& xs) (fn* (fn) (apply fn xs))))

  (def! reduce
    (fn* (seed f xs)
      (if (empty? xs)
        seed
        (reduce (f seed (car xs)) f (cdr xs)))))

  (def! every?
    (fn* (pred xs)
      (if (empty? xs)
        true
        (if (pred (car xs))
          (every? pred (cdr xs))
          false))))

  (def! some?
    (fn* (pred xs)
      (if (empty? xs)
        false
        (if (pred (car xs))
          true
          (some? pred (cdr xs))))))

  ;(def! letrec* (macro* (alias expr)
  ;  `(let* (~(car alias) (fix (fn* (~(car alias)) ~(2nd alias)))) ~expr)))

  (def! letmemrec* (macro* (alias expr)
    `(let* (~(car alias) (memfix (fn* (~(car alias)) ~(2nd alias)))) ~expr)))

  (def! skip (fn* (nbr xs)
    (letrec* (-skip- (fn* (ys)
      (let* (nbr (car ys)
             xs (2nd ys))
        (cond
          (= 0 nbr) xs
          (= 1 nbr) (cdr xs)
          "default" (-skip- (list (decr nbr) (cdr xs)))))))
      (-skip- (list nbr xs)))))

  (def! . (macro* (x key & xs)
    `((get ~x ~key) ~@xs)))

  (def! .. (fn* (lo hi)
    (letrec* (-..- (fn* (ys)
      (let* (lo     (1st ys)
             hi     (2nd ys)
             -list- (3rd ys))
        (if (= lo hi)
          (cons hi -list-)
          (-..- (list lo (decr hi) (cons hi -list-)))))))
      (-..- (list lo hi '())))))

)

; read-string
; slurp
; inner-comment macro
; *ARGV*
; load-file
; eval (esp. with configurable parameters)

; fix determination of equality
; symbol-keys (like :abc)
; amend results from "str" function
; pr-str, str, prn, println, readline, read-string, slurp
; readline
; *host-language*
; gensym -- for hygienic macros

; throw
; try catch

; ^
; @

; -----------
; METADATA
; -----------

; (def! x1 ^{"abc" 1} (fn* (a) (+ 1 a)))      ; => ???
; (meta x1)                                   ; => { "abc" 1 }

  ;(defmacro! and
  ;  (fn* (& xs)
  ;    (if (empty? xs)
  ;      true
  ;      (if (= 1 (count xs))
  ;        (first xs)
  ;        (let* (condvar (gensym))
  ;          `(let* (~condvar ~(first xs))
  ;            (if ~condvar (and ~@(rest xs)) ~condvar)))))))

  ;(defmacro! cond
  ;  (fn* (& clauses)
  ;    (if (> (count clauses) 0)
  ;      (list 'if (first clauses)
  ;            (if (> (count clauses) 1)
  ;                (nth clauses 1)
  ;                (throw "cond requires an even number of forms"))
  ;            (cons 'cond (rest (rest clauses)))))))


; defined?
