(do

  (def! 1st car)
  (def! 2nd (fn* (xs) (nth 1 xs)))
  (def! 3rd (fn* (xs) (nth 2 xs)))

  (def! or (macro* (& xs)
    (if (empty? xs)
      false
      `(let* (-query- ~(car xs))
        (if -query- 
          -query-
          (or ~@(cdr xs)))))))

  (def! and (macro* (& xs)
    (if (empty? xs)
      true
      `(let* (-query- ~(car xs))
        (if -query-
          (and ~@(cdr xs))
          false)))))

  (def! cond (macro* (& xs)
    (if (or (empty? xs) (empty? (cdr xs)))
      nil
      `(let* (-query- ~(car xs))
        (if -query-
          ~(2nd xs)
          (cond ~@(cdr (cdr xs))))))))

  (def! -> (macro* (& xs)
    (if (empty? xs)
      nil
      (let* (x  (car xs)
             xs (cdr xs))
        (if (empty? xs)
          x
          (let* (form  (car xs)
                 forms (cdr xs))
            (if (empty? forms)
              (if (list? form)
                (if (= (symbol "fn*") (car form))
                  `(~form ~x)
                  `(~(car form) ~x ~@(cdr form)))
                (list form x))
              `(-> (-> ~x ~form) ~@forms))))))))

  (def! ->> (macro* (& xs)
    (if (empty? xs)
      nil
      (let* (x  (car xs)
             xs (cdr xs))
        (if (empty? xs)
          x
          (let* (form  (car xs)
                 forms (cdr xs))
            (if (empty? forms)
              (if (list? form)
                (if (= (symbol "fn*") (car form))
                  `(~form ~x)
                  `(~@form  ~x))
                (list form x))
              `(->> (->> ~x ~form) ~@forms))))))))

  (def! ->* (macro* (& xs) `(fn* (-x-) (-> -x- ~@xs))))

  (def! ->>* (macro* (& xs) `(fn* (-x-) (->> -x- ~@xs))))

  (def! inc   (->* (+ 1)))
  (def! dec   (->* (- 1)))
  (def! zero? (->* (= 0)))

  (def! skip (fn* (nbr xs)
    (if (= 0 nbr)
      xs
      (let* (_skip (fn* (nbr xs)
        (if (= 1 nbr)
          (cdr xs)
          (_skip (- nbr 1) (cdr xs)))))
        (_skip nbr xs)))))

  (def! not (fn* (x) (if x false true)))

  (def! identity (fn* (x) x))

  (def! reduce
    (fn* (seed f xs)
      (if (empty? xs)
        seed
        (reduce (f seed (car xs)) f (cdr xs)))))

  (def! every?
    (fn* (pred xs)
      (if (empty? xs)
        true
        (if (pred (car xs))
          (every? pred (cdr xs))
          false))))

  (def! some?
    (fn* (pred xs)
      (if (empty? xs)
        false
        (if (pred (car xs))
          true
          (some? pred (cdr xs))))))

)

; read-string
; slurp
; inner-comment macro
; *ARGV*
; load-file
; eval (esp. with configurable parameters)
; def! a (atom 2)
; (atom? a) ; => true
; (deref a) ; => 2
; (reset! a 3)
; (swap! a incr)
; (swap! a + 3)
; (def! f0 (fn* () (swap! a incr)))
; (f0)
; enable `load-file` of a file that contains a multi-line map
; fix determination of equality
; symbol-keys (like :abc)
; amend results from "str" function
; pr-str, str, prn, println, readline, read-string, slurp
; readline
; *host-language*
; gensym -- for hygienic macros

; -----------
; METADATA
; -----------
; (meta (fn* (a) a)) ; => nil
; (meta (with-meta (fn* (a) a) { "b" 1 })) ; => { "b" 1 }
; (meta (with-meta (fn* (a) a) "abc"))     ; => "abc"

; (def! x0 (with-meta (fn* (a) a) { "b" 2 })) ; => ???
; (meta x0)                                   ; => { "b" 2 }
; (meta (with-meta x0 { "c" 3 }))             ; => { "c" 3 }
; (meta x0)                                   ; => { "b" 2 }

; (def! x1 ^{"abc" 1} (fn* (a) (+ 1 a)))      ; => ???
; (meta x1)                                   ; => { "abc" 1 }

; (meta +) ; => nil

; (def! gen-plusX (fn* (x) (with-meta (fn* (y) (+ x y) { "meta" 1 }))))
; (def! plus7 (gen-plusX 7))
; (plus7 8) ; => 15
; (meta plus7) ; => { "meta" 1 }

; (meta '(1 2 3)) ; => nil
; (with-meta '(1 2 3) { "a" 1 }) ; => '(1 2 3)
; (meta (with-meta '(1 2 3) { "a" 1 })) ; => { "a" 1 }


  ;(defmacro! and
  ;  (fn* (& xs)
  ;    (if (empty? xs)
  ;      true
  ;      (if (= 1 (count xs))
  ;        (first xs)
  ;        (let* (condvar (gensym))
  ;          `(let* (~condvar ~(first xs))
  ;            (if ~condvar (and ~@(rest xs)) ~condvar)))))))


  ;(defmacro! cond
  ;  (fn* (& clauses)
  ;    (if (> (count clauses) 0)
  ;      (list 'if (first clauses)
  ;            (if (> (count clauses) 1)
  ;                (nth clauses 1)
  ;                (throw "cond requires an even number of forms"))
  ;            (cons 'cond (rest (rest clauses)))))))
