(do
  (def! testIndex 0)

  (def! test (fn* (msg expected actual)
    (do
      ;(println testIndex)
      ;(println msg)
      (def! testIndex (+ testIndex 1))
      ;(println expected)
      ;(println actual)
      (println (= expected actual)))))

  (test "+"  10 (+ 1 2 3 4))
  (test "*"  24 (* 1 2 3 4))
  (test "-"  94 (- 100 1 2 3))
  (test "/"  10 (/ 100 2 5))
  (test "**" 81 (** 3 2 2))

  (test "if" 0 (if true 0 1))
  (test "if" 1 (if false 0 1))
  (test "if" 0 (if (= 0 0) 0 1))
  (test "if" 1 (if (< 0 0) 0 1))
  (test "if" 0 (if (= 0 0) (+ 0 0) 1))
  (test "if" 1 (if (< 0 0) (+ 0 0) (+ 0 1)))
  
  (def! --test-var-0-- 5)
  (test "def!" 5 --test-var-0--)
  (undef! --test-var-0--)

  (test "def!" 5 (def! --test-var-1-- 5))
  (undef! --test-var-1--)

  (test "let*" 5 (let* (x 5) x))

  (test "number?" true  (number? 0))
  (test "number?" false (number? "zero"))
  (test "number?" true (number? '0))
  (test "number?" false (number? (fn* () nil)))
  (test "number?" false (number? +))

  (test "nil?" true (nil? nil))

  (test "boolean?" true (boolean? true))
  (test "boolean?" true (boolean? false))

  (test "string? of strings" true  (string? "hello"))
  (test "string? of symbols" false (string? 'hello))
  (test "string? of numbers" false (string? 50))

  (test "function? of core fn" true (function? +))
  (test "function? of user-defined fn"  true (function? (fn* () nil)))

  (test "equiv numbers are equal" true (= 17 17))
  (test "inequiv numbers are unequal" false (= 17 19))
  (test "equiv strings are equal" true (= "hello0" "hello0"))
  (test "inequiv strings are unequal" false (= "hello0" "hello1"))
  (test "true is equal to true" true (= true true))
  (test "false is equal to false" true (= false false))
  (test "nil is equal to nil" true (= nil nil))
  (test "true is not equal to false" false (= true false))
  (test "false is not equal to nil" false (= false nil))
  (test "equiv lists are equal" true (= '(1 "hello1" '(1 '(2 '(3))) {"a" 5}) '(1 "hello1" '(1 '(2 '(3))) {"a" 5})))
  (test "inequiv lists are unequal" false (= '(1 "hello1" '(1 '(2 '(3))) {"a" 5}) '(1 "hello1" '(1 '(2 '(3))) {"a" 4})))
  (test "empty index is equal to empty index" true (= {} {}))
  (test "equiv indices are equal" true (= {"a" 1 "b" "hello1" 0 '(1 '(2 '(3))) 1 {"a" 5}} {"a" 1 "b" "hello1" 0 '(1 '(2 '(3))) 1 {"a" 5}}))
  (test "inequiv indices are unequal" false (= {"a" 1 "b" "hello1" 0 '(1 '(2 '(3))) 1 {"a" 5}} {"a" 1 "b" "hello1" 0 '(1 '(2 '(3))) 1 {"a" 4}}))

  (test "atom?" true (atom? (atom 5)))
  (test "deref" 10 (deref (atom 10)))
  (test "reset!" 10 (deref (reset! (atom 100) 10)))
  (test "swap! with fn" 10 (swap! (atom 9) incr))
  (test "swap! with fn and arg" 10 (swap! (atom 5) + 5))

  (test "closure" 12 (((fn* (a) (fn* (b) (+ a b))) 5) 7))

  (test "or with no args" false (or))
  (test "or with all 'false'" false (or false false false false))
  (test "or with a 'true'" true (or false false true false))
  (test "or with all false invocations" false (or false (= 0 1) (= 0 1) false))
  (test "or with a true invocation" true (or false (= 0 1) (< 0 1) false))

  (test "and with no args" true (and))
  (test "and with all 'false'" false (and false false false false))
  (test "and with a 'true'" false (and false false true false))
  (test "and with all 'true'" true (and true true true true))
  (test "and with a false invocation" false (and true (< 0 1) (< 0 1) (= 0 1)))
  (test "and with all true invocations" true (and true (< 0 1) (< 0 1) (< 0 1)))

  (test "cond with no args" nil (cond))

  (def! -error-msg- "`cond` requires an even number of forms.")
  (test "cond with a single 'true' arg" -error-msg- (try* (cond true) (catch* e e)))
  (test "cond with a single 'false' arg" -error-msg- (try* (cond false) (catch* e e)))
  (test "cond with a single invocation" -error-msg- (try* (cond (= 0 0)) (catch* e e)))

  (test "cond with a true invocation" 0 (cond (= 0 0) 0))
  (test "cond with a false invocation" nil (cond (< 0 0) 0))
  (test "cond with two branches" 1 (cond (< 0 0) 0 (= 0 0) 1))
  (test "cond with multiple branches" 3 (cond (< 0 0) 0 (< 0 0) 1 (< 0 0) 2 (= 0 0) 3))

  (test "cond with odd nbr args and no early true" -error-msg- (try* (cond false 0 false 1 false) (catch* e e)))
  (test "cond with odd nbr args but early true" 0 (cond true 0 false 1 false))
  (undef! --error-msg-)

  (test "->"  10  (-> 1000 (/ 100)))
  (test "->>" 100 (->> 1   (/ 100)))

  (test "->* creates a function"  true (function? (->*  (/ 100))))
  (test "->>* creates a function" true (function? (->>* (cons 'prefix))))

  (test "->*"  10  ((->* (/ 100)) 1000))
  (test "->>*" 100 ((->>* (/ 100)) 1))

  (test "constant-fn creates a function" true (function? (constant-fn 10)))
  (test "constant-fn" 10 ((constant-fn 10) 100))

  (test "call-on" 10 ((call-on 9) incr))

  (test "load multiline index" 20 (let* (idx (load "multiline_map")) (get (get idx "key3") "key1")))

  (def! -add- (fn* (x y) (if (= 0 x) y (-add- (- x 1) (+ x y)))))
  (test "tail-call optimization" 50005000 (-add- 10000 0))
  (undef! -add-)

  ;(test "\ form" 12 ((\ + _ (* _ _)) 3))

  "tests complete"
)
