serialize = require './serialize'
log = (arg1, args...) ->
  console.log ('---', arg1, args...)
logValue = (name, value) ->
  console.log ("--- #{name} =", serialize(value), value)
logResult = (result, args...) ->
  console.log ("------ result =", serialize(result), result, args...)
  result

{ addEnv }                   = require './env-utilities'
{ car }                      = require './linked-list'
{ cdr }                      = require './linked-list'
commentSignal                = require './commentSignal'
{ concat }                   = require './linked-list'
{ cond }                     = require './keyTokens'
{ createMalList }            = require './mal-type-utilities'
{ createMalMacro }           = require './mal-type-utilities'

{ createMalNumber }           = require './mal-type-utilities'

{ createMalString }          = require './mal-type-utilities'
{ createMalSymbol }          = require './mal-type-utilities'
{ createMalUserFunction }    = require './mal-type-utilities'
{ def! }                     = require './keyTokens'
{ _do }                      = require './keyTokens'
{ empty? }                   = require './linked-list' 
extractJsValue               = require './extractJsValue'
{ fn* }                      = require './keyTokens'
{ forEach }                  = require './linked-list'
{ _if }                      = require './keyTokens'
{ let* }                     = require './keyTokens'
{ lookup }                   = require './env-utilities'
{ macro* }                   = require './keyTokens'
{ malCoreFunction? }         = require './mal-type-utilities'
{ malList? }                 = require './mal-type-utilities'
{ malMacro? }                = require './mal-type-utilities'
{ malNil }                   = require './mal-type-utilities'
{ malSymbol? }               = require './mal-type-utilities'
{ malUserFunction? }         = require './mal-type-utilities'
{ map }                      = require './linked-list'
{ next }                     = require './linked-list'
{ quasiquote }               = require './keyTokens'
{ quote }                    = require './keyTokens'
{ spliceUnquote }            = require './keyTokens'
{ unquote }                  = require './keyTokens'
{ recurse }                  = require './linked-list'
{ reduce }                   = require './linked-list'
{ reduceBy2 }                = require './linked-list'
{ reverse }                  = require './linked-list'
{ setMainEnv }               = require './env-utilities'
{ toArray }                  = require './linked-list'

createFn = (head, malList, envs) ->
  createMalUserFunction
    malExpression : (next malList)
    malParameters : (car malList)

SPLAT-TOKEN = '&'
createLocalEnv = (jsParams, malArgs) ->
  env = {}
  until empty? jsParams
    jsParam = car jsParams
    if jsParam == SPLAT-TOKEN
      env[next jsParams] = malArgs
      return env
    else
      env[jsParam] = car malArgs
      jsParams = cdr jsParams
      malArgs = cdr malArgs
  env

createMacro = (head, malList, envs) ->
  createMalMacro
    malExpression : (car (cdr malList))
    malParameters : (car malList)

defineNewValue = (head, malList, envs) ->
  jsKey = extractJsValue (car malList)
  malValue = _evaluate ((next malList), envs)
  setMainEnv (envs, jsKey, malValue)

MALQUOTE  = createMalSymbol quote
MALCONS   = createMalSymbol 'cons'
MALCONCAT = createMalSymbol 'concat'

doQuote = \malExpr ->
  log 'doQuote'
  result = createMalList (
    MALQUOTE,
    (createMalList malExpr))
  logResult result

doCons = (malExpr, malList) ->
  createMalList (
    MALCONS,
    createMalList (malExpr, (createMalList malList)))

doConcat = (malList0, malList1) ->
  log 'doConcat'
  log 'malList0: ', (serialize malList0)
  log 'malList1: ', (serialize malList1)
  log 'createMalList (malList0, malList1): ', (serialize (createMalList (malList0, malList1)))
  createMalList (
    MALCONCAT,
    createMalList (malList0, malList1))

evalAllSideEffects = (head, malList, envs) ->
  forEach ((evaluate envs), malList)

evalCondition = (head, malList, envs) ->
  jsBool = extractJsValue (_evaluate ((car malList), envs))
  malExpr = if jsBool then next malList else next (cdr malList)
  _evaluate (malExpr, envs)

evalDefault = (malExpr, envs) ->
  malExpr

evalInvocation = (malSymbol, malList, envs) ->
  malInvokable = _evaluate (malSymbol, envs)
  invoke = switch
    when malMacro? malInvokable        then invokeMacro
    when malCoreFunction? malInvokable then invokeCoreFn
    when malUserFunction? malInvokable then invokeUserFn
    else throw 'Value is not a function'
  invoke (malInvokable, map ((evaluate envs), malList), envs)

evalList = (malList, envs) ->
  log 'evalList'
  head = car malList
  logValue 'head', head
  _eval = switch (extractJsValue head)
    when cond          then evalMultiCondition
    when def!          then defineNewValue
    when _do           then evalAllSideEffects
    when fn*           then createFn
    when macro*        then createMacro
    when _if           then evalCondition
    when let*          then evalWithLocalValue
    when quote
      log 'quote'
      evalQuote
    when quasiquote
      log 'quasiquote'
      evalQuasiquote
    when spliceUnquote
      log 'spliceUnquote'
      ((z, x, y) -> x)
    when unquote
      log 'unquote'
      ((z, x, y) -> x)
    else                    evalInvocation
  result = _eval (head, (cdr malList), envs)
  logResult result

evalMultiCondition = (head, malList, envs) ->
  until empty? malList
    condition = car malList
    jsBool = extractJsValue (_evaluate ((car condition), envs))
    return _evaluate ((next condition), envs) if jsBool
    malList = cdr malList
  malNil

cons = createMalList

_normalizeQuasiquote = \malExpr ->
  log '_normalizeQuasiquote'
  logValue 'malExpr', malExpr
  result = if unquotedExpr? malExpr
    log 'unquotedExpr'
    #car malExpr
    car (cdr malExpr)
  else if spliceUnquotedExpr? malExpr
    log 'spliceUnquotedExpr'
    concat ((car malExpr), (normalizeQuasiquote (cdr malExpr)))
  else if malList? malExpr
    log 'quasiquoted malExpr is a malList'
    map (normalizeQuasiquote, malExpr)
  else
    log 'default'
    malExpr
  logResult result

normalizeQuasiquote = \malExpr ->
  log 'normalizeQuasiquote'
  if not malList? malExpr
    log 'not malList'
    return logResult (doQuote malExpr)
  if empty? malExpr
    log 'empty'
    return logResult (doQuote malExpr)
  log 'must be malList then'
  logResult (_normalizeQuasiquote malExpr)

evalQuasiquote = (head, malList, envs) ->
  log 'evalQuasiquote'
  #result = _evaluate ((normalizeQuasiquote (car malList)), envs)
  result = normalizeQuasiquote (car malList)
  logResult result

evalQuote = (head, malList, envs) ->
  log 'evalQuote'
  logValue 'head', head
  logValue 'malList', malList
  car malList

evalSymbol = (malSymbol, envs) ->
  log 'evalSymbol'
  logValue 'malSymbol', malSymbol
  lookup (envs, (extractJsValue malSymbol))

_evaluate = (malExpr, envs) ->
  _eval = switch
    when malList? malExpr   then evalList
    when malSymbol? malExpr then evalSymbol
    else                         evalDefault
  _eval (malExpr, envs)

evaluate = \envs \malExpr ->
  return commentSignal if malExpr == commentSignal
  _evaluate (malExpr, envs)

evalWithLocalValue = (head, malList, envs) ->
  _reduce = (env, malKey, malExpr) ->
    envValue = _evaluate (malExpr, envs)
    jsKey = extractJsValue malKey
    env[jsKey] = envValue
    env
  newEnv = reduceBy2 ({}, _reduce, (car malList))
  _evaluate ((next malList), addEnv (envs, newEnv))

invokeMacro = (malMacro, malArgs, envs) ->
  _evaluate (invokeUserFn (malMacro, malArgs, envs), envs)

invokeCoreFn = (malCoreFunction, malArgs, envs) ->
  extractJsValue malCoreFunction malArgs

invokeUserFn = (malUserFunction, malArgs, envs) ->
  { malExpression, malParameters } = extractJsValue malUserFunction
  jsParameters = map (extractJsValue, malParameters)
  newEnv = createLocalEnv (jsParameters, malArgs)
  newEnvStack = addEnv (envs, newEnv)
  _evaluate (malExpression, newEnvStack)

spliceUnquote? = \malValue ->
  log 'check spliceUnquote?'
  spliceUnquote == (extractJsValue malValue)

spliceUnquotedExpr? = \malValue ->
  log 'check spliceUnquotedExpr?'
  malList? malValue && (spliceUnquote? (car malValue))

unquote? = \malValue ->
  log 'check unquote?'
  unquote == (extractJsValue malValue)

unquotedExpr? = \malValue ->
  log 'check unquotedExpr?'
  malList? malValue && (unquote? (car malValue))

module.exports = evaluate
