{ car }                   = require './linked-list'
{ cdr }                   = require './linked-list'
{ copy }                  = require './linked-list'
{ concat }                = require './linked-list'
{ createJsLinkedList }    = require './linked-list'
{ createMalAtom }         = require './mal-type-utilities'
{ createMalBoolean }      = require './mal-type-utilities'
{ createMalCoreFunction } = require './mal-type-utilities'
{ createMalIndex }        = require './mal-type-utilities'
{ createMalList }         = require './mal-type-utilities'
{ createMalNumber }       = require './mal-type-utilities'
{ createMalString }       = require './mal-type-utilities'
{ createMalSymbol }       = require './mal-type-utilities'
display                   = require './display'
{ drop }                  = require './linked-list'
{ empty? }                = require './linked-list'
{ evaluate }              = require './evaluate'
{ expandMacro }           = require './evaluate'
extractJsValue            = require './extractJsValue'
{ fromArray }             = require './linked-list'
interpret                 = require './interpret'
{ last }                  = require './linked-list'
{ malAtom? }              = require './mal-type-utilities'
{ malCoreFunction? }      = require './mal-type-utilities'
{ malBoolean? }           = require './mal-type-utilities'
{ malFalse }              = require './mal-type-utilities'
{ malList? }              = require './mal-type-utilities'
{ malNil }                = require './mal-type-utilities'
{ malNil? }               = require './mal-type-utilities'
{ malNumber? }            = require './mal-type-utilities'
{ malString? }            = require './mal-type-utilities'
{ malSymbol? }            = require './mal-type-utilities'
{ malTrue }               = require './mal-type-utilities'
{ malUserFunction? }      = require './mal-type-utilities'
{ next }                  = require './linked-list'
_process_                 = require './process'
{ recurse }               = require './linked-list'
{ reduce }                = require './linked-list'
{ reverse }               = require './linked-list'
serialize                 = require './serialize'
{ take }                  = require './linked-list'
{ toArray }               = require './linked-list'
{ toPartialArray }        = require './linked-list'

add = (nbrs...) ->
  createMalNumber (nbrs.reduce ((x, nbr) ->  x += nbr))
subtract = (nbrs...) ->
  createMalNumber (nbrs.reduce ((x, nbr) -> x -= nbr))
multiply = (nbrs...) ->
  createMalNumber (nbrs.reduce ((x, nbr) -> x *= nbr))
divide = (nbrs...) ->
  createMalNumber (nbrs.reduce ((x, nbr) -> x /= nbr))
exponentiate = (nbrs...) ->
  createMalNumber (nbrs.reduce ((x, nbr) -> Math.pow (x, nbr)))
negate = \nbr ->
  createMalNumber (-1 * nbr)
greaterThan = (nbrs...) ->
  createMalBoolean (nbrs[0] > nbrs[1])
lessThan = (nbrs...) ->
  createMalBoolean (nbrs[0] < nbrs[1])
lessThanOrEqual = (nbrs...) ->
  createMalBoolean (nbrs[0] <= nbrs[1])
greaterThanOrEqual = (nbrs...) ->
  createMalBoolean (nbrs[0] >= nbrs[1])

_not = \bool ->
  createMalBoolean (!bool)

deref = \malArgs ->
  (car malArgs).malValue

setMalValue = (malAtom, malValue) ->
  malAtom.malValue = malValue
  malAtom

lift = (fnOnJsValues, fnName) ->
  __fn__ = (malValueList) ->
    fnOnJsValues (((toArray malValueList).map extractJsValue)...)
  { fn: __fn__, fnName }

setCoreFnsOnJsValues! = (env, fns) ->
  for own fnName, fn of fns
    env[fnName] = createMalCoreFunction (lift (fn, fnName))

functionsOnJsValues = {
  '+'      : add
  '/'      : divide
  '>'      : greaterThan
  '>='     : greaterThanOrEqual
  '<'      : lessThan
  '<='     : lessThanOrEqual
  '*'      : multiply
  '**'     : exponentiate
  'negate' : negate
  'not'    : _not
  '-'      : subtract
  'get'    : (jsIndex, jsKey) -> jsIndex[jsKey]
  'assoc' : (index, args...) ->
    copy = {}
    for own key, value of index
      copy[key] = value
    for k, i in args when i % 2 == 0
      copy[k] = args[i + 1]
    createMalIndex copy
  'index'  : (args...) ->
    index = {}
    index[k] = args[i + 1] for k, i in args when i % 2 == 0
    createMalIndex index
  'dissoc' : (index, keys...) ->
    copy = {}
    for own key, value of index
      copy[key] = value
    delete copy[key] for key in keys
    createMalIndex copy
  'contains?' : (index, key) -> key of index
  'keys'      : (index) ->
    keys = []
    for own key, value of index
      keys.push key
    fromArray keys
  'vals'      : (index) ->
    values = []
    for own key, value of index
      values.push value
    fromArray values
}

# TODO: Refactor
# ---------------------------------------------------------
_areEqual = (malValue0, malValue1) ->
  malValue0 == malValue1 ||
    malValue0.jsValue == malValue1.jsValue

__areEqual = (malValue0, malValue1) ->
  if _areEqual (malValue0, malValue1)
    return true

  areBothLists? = malList? malValue0 && malList? malValue1

  if areBothLists?
      l0 = malValue0.jsValue
      l1 = malValue1.jsValue
      result = true
      # TODO: Make more efficient.
      until empty? l0 || empty? l1
        result = result &&
          __areEqual (l0.value, l1.value)
        l0 = recurse l0
        l1 = recurse l1
      result && empty? l0 && empty? l1
    else
      false

# TODO: Refactor.
areEqual = \malArgs ->
  [malValue0, malValue1] = toArray malArgs
  createMalBoolean (__areEqual (malValue0, malValue1))
# ---------------------------------------------------------

# TODO
apply = \malArgs ->
  [malFn, malArgList] = toArray malArgs
  evaluate [] (createMalList (malFn, malArgList))

call = \malArgs ->
  evaluate [] malArgs

cons = \malArgs ->
  createMalList (
    car malArgs
    next malArgs)

stem = \fn \malArgs ->
  fn (car malArgs)

_concat = \malArgs ->
  malLists = toArray malArgs
  concat malLists...

append = \malArgs ->
  [malList, malValues...] = toArray malArgs
  concat (malList, (fromArray malValues))

count = \malArgs ->
  _reduce = (sum, value) -> sum + 1
  createMalNumber (reduce (0, _reduce, (car malArgs)))

createPredicate = \pred \jsList ->
  malValue = jsList.value
  createMalBoolean (pred malValue)

# WET; cf. `_take`.
_drop = \malArgs ->
  [malNumber, malList] = toPartialArray (2, malArgs)
  drop ((extractJsValue malNumber), malList)

_evaluate_ = \jsString ->
  _process_ [environment] jsString

_evaluateString = \malArgs ->
  _evaluate_ (stripQuotes (extractJsValue (car malArgs)))

_evaluate = \malArgs ->
  evaluate [environment] (car malArgs)

_expandMacro = \malArgs ->
  [malMacro, malArgList] = toPartialArray (2, malArgs)
  expandMacro (malMacro, malArgList, [])

first = \malArgs ->
  car (car malArgs)

list = \malArgs ->
  malArgs

load = \malArgs ->
  _evaluate_ (_read malArgs)

map = \malArgs ->
  [malFn, malArgList] = toArray malArgs
  _malArgs = toArray malArgList
  __malArgs = _malArgs.map \x -> createMalList (malFn, createMalList (x))
  results = __malArgs.map (evaluate [])
  fromArray results

malReduce = \malArgs ->
  [malSeed, malFn, malArgList] = toArray malArgs
  _malArgs = toArray malArgList
  _reduce = (memo, item) ->
    _memo = if malList? memo
        createMalList (
          createMalSymbol 'quote'
          createMalList memo)
      else
        memo
    evaluate [] (
      createMalList (
        malFn
        createMalList (
          _memo
            createMalList item)))
  _malArgs.reduce (_reduce, malSeed)

nth = \malArgs ->
  [malNumber, malList] = toPartialArray (2, malArgs)
  for i in [0 ... (extractJsValue malNumber)]
    malList = cdr malList
  car malList

prepend = \malArgs ->
  [malList, malValues...] = toArray malArgs
  _reduce = (list, val) ->
    createMalList (val, list)
  malValues.reduce (_reduce, malList)

_quit_ = ->
  process.exit 0

_interpret = \malArgs ->
  interpret (stripQuotes (extractJsValue (car malArgs)))

_prStr = (malArgs, printReadably?) ->
  ((toArray malArgs).map \malArg -> serialize (malArg, printReadably?))

prStr = \malArgs ->
  (_prStr (malArgs, true)).join ''

str = \malArgs ->
  (_prStr (malArgs, false)).join ''

prn = \malArgs ->
  display ((_prStr (malArgs, true))...)
  malNil

println = \malArgs ->
  display ((_prStr (malArgs, false))...)
  malNil

_read = \malArgs ->
  jsFileName = stripQuotes (extractJsValue (car malArgs))
  require('fs').readFileSync(jsFileName).toString()

read = \jsList ->
  createMalString (_read jsList)

rest = \malArgs ->
  arg = car malArgs
  if malList? arg then cdr arg else malNil

setCoreFnsOnMalValues! = (env, fns) ->
  for own fnName, fn of fns
    env[fnName] = createMalCoreFunction { fn, fnName }

stripQuotes = \jsString ->
  jsString[1 .. -2]

_take = \malArgs ->
  [malNumber, malList] = toPartialArray (2, malArgs)
  take ((extractJsValue malNumber), malList)

typeOf = \malArgs ->
  malValue = car malArgs
  createMalString malValue.type 

_throw = \malArgs ->
  throw (serialize (car malArgs))

time-ms = () ->
  createMalNumber (new Date().getTime ())

write = \malArgs ->
  createMalString (serialize (car malArgs))

[atom?, boolean?, list?, nil?, number?, symbol?, string?, coreFn?, userFn?] =
  [ malAtom?
    malBoolean?
    malList?
    malNil?
    malNumber?
    malSymbol?
    malString?
    malCoreFunction?
    malUserFunction?
  ].map createPredicate

function? = \jsList ->
  malValue = jsList.value
  createMalBoolean (malCoreFunction? malValue || malUserFunction? malValue)

_car = \malArgs ->
  arg = car malArgs
  if malList? arg then car arg else malNil

_cdr = \malArgs ->
  arg = car malArgs
  if malList? arg then cdr arg else malNil

_empty? = \malArgs ->
  if empty? malArgs
    malFalse
  else
    if empty? (car malArgs) then malTrue else malFalse

_last = \malArgs ->
  arg = car malArgs
  if malList? arg then last arg else malNil

_reverse = \malArgs ->
  arg = car malArgs
  if malList? arg then reverse arg else malNil

symbol = \malArgs ->
  malValue = car malArgs
  if malString? malValue
    jsStr = extractJsValue malValue
    createMalSymbol jsStr[1 ... -1]
  else
    malNil

functionsOnMalValues = {
  '='        : areEqual
  'append'   : append
  'apply'    : apply
  'atom'     : \malArgs -> createMalAtom (car malArgs)
  'atom?'    : atom?
  'boolean?' : boolean?
  'car'      : _car
  'call'     : call
  'cdr'      : _cdr
  'cons'     : cons
  'concat'   : _concat
  'core-fn?' : coreFn?
  'count'    : count
  'deref'    : deref
  'drop'     : _drop
  'empty?'   : _empty?
  'eval'     : _evaluate
  'evalStr'  : _evaluateString
  'expand-macro' : _expandMacro
  'first'    : _car
  'function?' : function?
  'last'     : _last
  'list'     : list
  'list?'    : list?
  'load'     : load
  'map'      : map
  'nil?'     : nil?
  'nth'      : nth
  'number?'  : number?
  'parse'    : _interpret
  'prepend'  : prepend
  'println'  : println
  'prn'      : prn
  'prStr'    : prStr
  '-quit-'   : _quit_
  'read'     : read
  'reduce'   : malReduce
  'reset!'   : \malArgs ->
    [atom, value] = toPartialArray (2, malArgs)
    setMalValue (atom, value)
  'rest'     : _cdr
  'reverse'  : _reverse
  'str'      : str
  'string?'  : string?
  'symbol'   : symbol
  'symbol?'  : symbol?
  'write'    : write
  'take'     : _take
  'throw'    : _throw
  'time-ms'  : time-ms
  'typeof'   : typeOf
  'user-fn?' : userFn?
  'set!'      : \malArgs ->
    [index, key, val] = toPartialArray (3, malArgs)
    (extractJsValue index)[extractJsValue key] = val
    index
  'with-meta' : \malArgs ->
    [malVal, malMeta] = toPartialArray (2, malArgs)
    if malAtom? malVal
      { malValue, type } = malVal
      { malValue, type, meta: malMeta }
    else
      { jsValue, type } = malVal
      { jsValue, type, meta: malMeta }
  'meta'      : \malArgs ->
    malMeta = (car malArgs).meta
    if ? malMeta then malMeta else malNil
}

environment = {}

setCoreFnsOnJsValues! (environment, functionsOnJsValues)
setCoreFnsOnMalValues! (environment, functionsOnMalValues)

module.exports = environment
